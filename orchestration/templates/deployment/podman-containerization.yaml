template_id: "deployment-podman-containerization"
template_name: "Podman Rootless Containerization"
category: "deployment"
difficulty: "medium"
estimated_loc: "1000-3000"

keywords:
  - "podman"
  - "container"
  - "rootless"
  - "daemonless"
  - "containerfile"
  - "dockerfile"
  - "pod"
  - "deployment"

parameters:
  - name: "deployment_style"
    type: "string"
    options: ["single_container", "pod", "compose"]
    default: "single_container"
  - name: "features"
    type: "array"
    options: ["rootless", "systemd_integration", "multi_stage_build", "secrets"]

core_interfaces:
  - name: "ContainerConfig"
    fields:
      - "image: String"
      - "volumes: Vec<VolumeMount>"
      - "environment: HashMap<String, String>"
      - "ports: Vec<PortMapping>"

recommended_libraries:
  rust:
    - name: "bollard"
      version: "0.15"
      required: false
      purpose: "Docker/Podman API client (compatible with Podman)"
      registry_url: "https://crates.io/crates/bollard"
  python:
    - name: "podman"
      version: "4.8"
      required: true
      purpose: "Official Podman Python bindings"
      registry_url: "https://pypi.org/project/podman/"

acceptance_criteria:
  - "Build container images from Containerfile"
  - "Run containers rootless (no sudo required)"
  - "Daemon-less operation (no background service)"
  - "Volume mounting with proper permissions"
  - "Pod support (multi-container coordination)"
  - "Systemd integration (auto-start containers)"
  - "Multi-stage builds (small final images)"
  - "Performance: Start container in < 2 seconds"

test_strategy:
  unit_tests:
    - "Containerfile syntax validation"
    - "Volume mount configuration"
  integration_tests:
    - "Full build → run → stop → remove workflow"
    - "Pod creation with multiple containers"
    - "Systemd service generation and activation"
  security_tests:
    - "Verify rootless operation (no escalation)"
    - "Check SELinux contexts"
  platform_tests:
    - "Test on Fedora, Ubuntu, RHEL"

implementation_hints:
  - "Use 'Containerfile' (Podman native) or 'Dockerfile' (compatible)"
  - "Run rootless: podman run --userns=keep-id"
  - "Volume mounting: use :Z suffix for SELinux (podman run -v /host:/container:Z)"
  - "Generate systemd units: podman generate systemd --name mycontainer"
  - "Use pods: podman pod create --name mypod; podman run --pod mypod"
  - "Multi-stage builds: FROM base AS builder; FROM runtime; COPY --from=builder"
  - "No daemon: each podman command is self-contained"

common_pitfalls:
  - issue: "Volume permission errors"
    solution: "Use --userns=keep-id and :Z flag: -v /path:/path:Z"
  - issue: "Containers not restarting after reboot"
    solution: "Enable systemd user service: systemctl --user enable container-myapp"
  - issue: "Network connectivity issues between pods"
    solution: "Ensure pods share network: --network=host or --pod"
  - issue: "Large image sizes"
    solution: "Use multi-stage builds, Alpine base images"
  - issue: "Can't bind to privileged ports (< 1024)"
    solution: "Use port mapping: -p 8080:80 (host 8080 → container 80)"

podman_vs_docker:
  compatibility:
    description: "Podman is mostly Docker-compatible"
    command_mapping: "docker → podman (alias works)"
    dockerfile: "Dockerfile works, Containerfile is Podman native"
  differences:
    daemon: "Docker has daemon, Podman is daemonless"
    rootless: "Podman rootless by default, Docker requires setup"
    pods: "Podman has pods (Kubernetes-like), Docker doesn't"
    systemd: "Podman integrates with systemd, Docker uses Docker service"
  incompatibilities:
    docker_socket: "Podman uses REST API, not /var/run/docker.sock"
    buildkit: "Some BuildKit features not supported"
    docker_compose: "Use podman-compose instead (separate tool)"

security_advantages:
  rootless:
    description: "Run as non-root user"
    benefit: "Container escape doesn't grant root access"
  daemonless:
    description: "No persistent background service"
    benefit: "Smaller attack surface, no single point of failure"
  user_namespace:
    description: "UID mapping (root in container = unprivileged on host)"
    benefit: "Prevents privilege escalation"
  selinux:
    description: "Full SELinux integration"
    benefit: "Additional mandatory access control"

example_containerfile: |
  # Multi-stage build example
  FROM rust:1.75 AS builder
  WORKDIR /app
  COPY Cargo.toml Cargo.lock ./
  COPY src ./src
  RUN cargo build --release

  FROM debian:bookworm-slim
  RUN apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*
  COPY --from=builder /app/target/release/myapp /usr/local/bin/
  USER nobody
  ENTRYPOINT ["/usr/local/bin/myapp"]

example_build_and_run: |
  # Build image
  podman build -t myapp:latest -f Containerfile .

  # Run rootless container
  podman run -d \
    --name myapp \
    --userns=keep-id \
    -v ./data:/app/data:Z \
    -p 8080:8080 \
    -e DATABASE_URL=postgres://... \
    myapp:latest

  # Check status
  podman ps

  # View logs
  podman logs myapp

  # Stop and remove
  podman stop myapp
  podman rm myapp

example_pod: |
  # Create pod (shared network namespace)
  podman pod create --name myapp-pod -p 8080:80

  # Run web server in pod
  podman run -d --pod myapp-pod --name web nginx:alpine

  # Run database in same pod
  podman run -d --pod myapp-pod --name db \
    -v ./pgdata:/var/lib/postgresql/data:Z \
    postgres:15

  # Containers in same pod can communicate via localhost
  # web can access db at localhost:5432

example_systemd: |
  # Generate systemd unit file
  podman generate systemd --name myapp --files

  # Move to systemd user directory
  mkdir -p ~/.config/systemd/user
  mv container-myapp.service ~/.config/systemd/user/

  # Enable and start service
  systemctl --user enable container-myapp
  systemctl --user start container-myapp

  # Enable lingering (service survives logout)
  loginctl enable-linger $USER

  # Check status
  systemctl --user status container-myapp

podman_compose_alternative: |
  # docker-compose.yml works with podman-compose
  # Install: pip install podman-compose

  # docker-compose.yml
  version: '3'
  services:
    web:
      build: .
      ports:
        - "8080:80"
      volumes:
        - ./data:/app/data
    db:
      image: postgres:15
      environment:
        POSTGRES_PASSWORD: secret

  # Run with podman-compose
  podman-compose up -d

related_templates:
  - "template://data/database-abstraction"
  - "template://quality/logging-observability"
  - "template://gui/cross-platform-packaging"
