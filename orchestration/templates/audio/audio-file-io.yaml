template_id: "audio-audio-file-io"
template_name: "Audio File I/O and Format Support"
category: "audio"
difficulty: "medium"
estimated_loc: "2000-4000"

keywords:
  - "audio"
  - "mp3"
  - "wav"
  - "flac"
  - "ogg"
  - "sound"
  - "music"
  - "file"
  - "load"
  - "save"

parameters:
  - name: "formats"
    type: "array"
    options: ["mp3", "wav", "flac", "ogg", "m4a", "aac"]
  - name: "features"
    type: "array"
    options: ["metadata", "streaming", "transcoding"]

core_interfaces:
  - name: "AudioFile"
    methods:
      - "fn load(path: &Path) -> Result<AudioFile, Error>"
      - "fn save(&self, path: &Path, format: AudioFormat) -> Result<(), Error>"
      - "fn sample_rate(&self) -> u32"
      - "fn channels(&self) -> u16"
      - "fn samples(&self) -> &[f32]"
  - name: "AudioMetadata"
    fields:
      - "title: String"
      - "artist: String"
      - "album: String"
      - "duration: Duration"
      - "bitrate: u32"

recommended_libraries:
  rust:
    - name: "symphonia"
      version: "0.5"
      required: true
      purpose: "Pure Rust audio decoding (MP3, FLAC, AAC, etc.)"
      registry_url: "https://crates.io/crates/symphonia"
    - name: "hound"
      version: "3.5"
      required: true
      purpose: "WAV file I/O"
      registry_url: "https://crates.io/crates/hound"
    - name: "lofty"
      version: "0.18"
      required: false
      purpose: "Audio metadata (ID3, Vorbis comments)"
      registry_url: "https://crates.io/crates/lofty"
    - name: "rodio"
      version: "0.17"
      required: false
      purpose: "Audio playback (supports multiple formats)"
      registry_url: "https://crates.io/crates/rodio"
  python:
    - name: "librosa"
      version: "0.10"
      required: true
      purpose: "Audio analysis and I/O"
      registry_url: "https://pypi.org/project/librosa/"
    - name: "soundfile"
      version: "0.12"
      required: true
      purpose: "Read/write audio files (libsndfile wrapper)"
      registry_url: "https://pypi.org/project/soundfile/"
    - name: "pydub"
      version: "0.25"
      required: false
      purpose: "Simple audio manipulation (uses FFmpeg)"
      registry_url: "https://pypi.org/project/pydub/"
    - name: "mutagen"
      version: "1.47"
      required: false
      purpose: "Audio metadata editing"
      registry_url: "https://pypi.org/project/mutagen/"

acceptance_criteria:
  - "Load MP3, WAV, FLAC, OGG files"
  - "Read audio metadata (title, artist, album, duration)"
  - "Save audio to multiple formats"
  - "Handle mono and stereo (and multi-channel)"
  - "Support various sample rates (16kHz to 192kHz)"
  - "Convert between sample formats (f32, i16, i32)"
  - "Performance: Load 5-minute audio file in < 1 second"

test_strategy:
  unit_tests:
    - "File format detection"
    - "Sample rate conversion"
    - "Channel conversion (mono ↔ stereo)"
    - "Metadata parsing"
  integration_tests:
    - "Load → process → save pipeline"
    - "Format transcoding (MP3 → WAV → FLAC)"
    - "Metadata preservation"
  validation_tests:
    - "Test with variety of sample files"
    - "Verify decoded samples match reference"
  benchmarks:
    - "Load time vs file size"
    - "Memory usage per format"

implementation_hints:
  - "Use symphonia for Rust (supports most formats)"
  - "Use librosa for Python (research/analysis focus)"
  - "soundfile for Python (production I/O, fast)"
  - "Store audio as f32 samples (-1.0 to 1.0)"
  - "Handle sample rate mismatch (resample if needed)"
  - "Use streaming for large files (don't load all into memory)"
  - "Normalize audio volume (-0.1 dBFS peak recommended)"

common_pitfalls:
  - issue: "Clipping when converting formats"
    solution: "Normalize to [-1.0, 1.0], check for clipping before save"
  - issue: "Slow MP3 decoding"
    solution: "Use minimp3 crate, or FFmpeg via pydub"
  - issue: "Metadata lost during transcoding"
    solution: "Explicitly copy metadata to output file"
  - issue: "Memory exhaustion on large files"
    solution: "Use streaming/chunked reading"
  - issue: "Sample rate mismatch causing distortion"
    solution: "Resample to consistent rate (librosa.resample)"
  - issue: "Mono/stereo confusion"
    solution: "Always check channels, convert explicitly"

audio_formats:
  wav:
    compression: "Uncompressed PCM"
    quality: "Lossless"
    size: "Large (~10MB/min stereo)"
    metadata: "Limited (RIFF INFO)"
  mp3:
    compression: "Lossy (MPEG-1 Layer 3)"
    quality: "Good (320kbps), fair (128kbps)"
    size: "Small (~2-5MB/min)"
    metadata: "ID3v2 tags"
  flac:
    compression: "Lossless"
    quality: "Perfect (bit-identical to source)"
    size: "Medium (~30-50% of WAV)"
    metadata: "Vorbis comments"
  ogg:
    compression: "Lossy (Vorbis/Opus)"
    quality: "Excellent at same bitrate as MP3"
    size: "Small (similar to MP3)"
    metadata: "Vorbis comments"

example_usage: |
  # Rust with symphonia
  use symphonia::core::io::MediaSourceStream;
  use symphonia::core::probe::Hint;

  let file = File::open("audio.mp3")?;
  let mss = MediaSourceStream::new(Box::new(file), Default::default());

  let mut hint = Hint::new();
  hint.with_extension("mp3");

  let probed = symphonia::default::get_probe()
      .format(&hint, mss, &Default::default(), &Default::default())?;

  let mut format = probed.format;
  let track = format.default_track().unwrap();
  let decoder = symphonia::default::get_codecs()
      .make(&track.codec_params, &Default::default())?;

  // Python with librosa
  import librosa
  import soundfile as sf

  # Load audio
  audio, sr = librosa.load("audio.mp3", sr=None)  # Preserve original sample rate
  print(f"Duration: {len(audio) / sr:.2f} seconds")

  # Save to different format
  sf.write("output.wav", audio, sr)

related_templates:
  - "template://audio/signal-processing"
  - "template://audio/feature-extraction"
  - "template://data/data-validation"
