template_id: "data-data-validation"
template_name: "Data Validation and Schema Enforcement"
category: "data"
difficulty: "medium"
estimated_loc: "1500-3000"

keywords:
  - "validation"
  - "schema"
  - "pydantic"
  - "serde"
  - "type checking"
  - "data integrity"
  - "constraint"
  - "validator"

parameters:
  - name: "validation_style"
    type: "string"
    options: ["declarative", "procedural"]
    default: "declarative"
  - name: "features"
    type: "array"
    options: ["type_checking", "range_validation", "custom_validators", "nested_objects"]

core_interfaces:
  - name: "Validator"
    methods:
      - "fn validate(&self, data: &Data) -> Result<ValidatedData, ValidationError>"
      - "fn add_rule(&mut self, field: &str, rule: ValidationRule)"
  - name: "Schema"
    methods:
      - "fn from_json(json: &str) -> Result<Schema, Error>"
      - "fn validate_against(&self, data: &Data) -> Vec<ValidationError>"

recommended_libraries:
  rust:
    - name: "serde"
      version: "1.0"
      required: true
      purpose: "Serialization/deserialization with type checking"
      registry_url: "https://crates.io/crates/serde"
    - name: "validator"
      version: "0.16"
      required: true
      purpose: "Validation derive macros"
      registry_url: "https://crates.io/crates/validator"
    - name: "schemars"
      version: "0.8"
      required: false
      purpose: "JSON Schema generation from Rust types"
      registry_url: "https://crates.io/crates/schemars"
  python:
    - name: "pydantic"
      version: "2.5"
      required: true
      purpose: "Data validation using Python type hints"
      registry_url: "https://pypi.org/project/pydantic/"
    - name: "marshmallow"
      version: "3.20"
      required: false
      purpose: "Object serialization/deserialization and validation"
      registry_url: "https://pypi.org/project/marshmallow/"
    - name: "cerberus"
      version: "1.3"
      required: false
      purpose: "Lightweight schema validation"
      registry_url: "https://pypi.org/project/Cerberus/"

acceptance_criteria:
  - "Validate required vs optional fields"
  - "Type checking (string, int, float, bool, etc.)"
  - "Range validation (min/max for numbers)"
  - "String validation (regex, length, email, URL)"
  - "Nested object validation"
  - "Custom validation rules"
  - "Clear error messages with field names"
  - "Performance: Validate 10,000 records in < 1 second"

test_strategy:
  unit_tests:
    - "Type validation (correct and incorrect types)"
    - "Range constraints (boundary conditions)"
    - "Required field enforcement"
    - "Custom validator logic"
  integration_tests:
    - "Complex nested structures"
    - "Batch validation of datasets"
  property_based_tests:
    - "Generate random data, verify validation consistency"
  benchmarks:
    - "Validation speed vs data complexity"

implementation_hints:
  - "Use pydantic for Python (type hints + validation)"
  - "Use serde + validator for Rust (derive macros)"
  - "Define schemas as classes/structs (declarative)"
  - "Use Field() for additional constraints (min, max, regex)"
  - "Implement custom validators for business logic"
  - "Collect all errors, not just first error"
  - "Generate JSON schemas for documentation"

common_pitfalls:
  - issue: "Validation too strict (rejecting valid data)"
    solution: "Use Optional types, provide sensible defaults"
  - issue: "Poor error messages ('invalid value')"
    solution: "Provide context: 'age must be between 0 and 150, got -5'"
  - issue: "Performance issues on large datasets"
    solution: "Validate in batches, use compiled validators"
  - issue: "Not handling nested validation"
    solution: "Use recursive validation for nested objects"
  - issue: "Silent failures (no validation errors raised)"
    solution: "Always check validation result, raise exceptions"

validation_types:
  type_validation:
    description: "Ensure correct data types"
    example: "age: int, email: str"
  range_validation:
    description: "Numeric constraints"
    example: "age >= 0 and age <= 150"
  pattern_validation:
    description: "String patterns (regex)"
    example: "email matches ^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$"
  custom_validation:
    description: "Business logic rules"
    example: "start_date must be before end_date"

example_python_pydantic: |
  from pydantic import BaseModel, Field, validator, EmailStr
  from typing import Optional
  from datetime import date

  class User(BaseModel):
      name: str = Field(..., min_length=1, max_length=100)
      age: int = Field(..., ge=0, le=150)
      email: EmailStr
      website: Optional[str] = None
      created_at: date

      @validator('website')
      def validate_website(cls, v):
          if v and not v.startswith('http'):
              raise ValueError('Website must start with http:// or https://')
          return v

  # Usage
  try:
      user = User(
          name="Alice",
          age=30,
          email="alice@example.com",
          website="https://alice.com",
          created_at=date.today()
      )
  except ValidationError as e:
      print(e.json())

example_rust_validator: |
  use serde::{Deserialize, Serialize};
  use validator::{Validate, ValidationError};

  #[derive(Debug, Validate, Deserialize, Serialize)]
  struct User {
      #[validate(length(min = 1, max = 100))]
      name: String,

      #[validate(range(min = 0, max = 150))]
      age: u8,

      #[validate(email)]
      email: String,

      #[validate(url)]
      website: Option<String>,
  }

  fn main() {
      let user = User {
          name: "Alice".to_string(),
          age: 30,
          email: "alice@example.com".to_string(),
          website: Some("https://alice.com".to_string()),
      };

      match user.validate() {
          Ok(_) => println!("Valid user"),
          Err(e) => println!("Validation errors: {:?}", e),
      }
  }

related_templates:
  - "template://data/database-abstraction"
  - "template://scientific/data-analysis"
  - "template://ai/rag-system"
